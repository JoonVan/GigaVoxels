////////////////////////////////////////////////////////////////////////////////
//
// TESSELATION EVALUATION SHADER
//
// Terrain rendering
//
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
// VERSION
////////////////////////////////////////////////////////////////////////////////

#version 400

////////////////////////////////////////////////////////////////////////////////
// INPUT
////////////////////////////////////////////////////////////////////////////////

// ...
layout( triangles, equal_spacing, cw ) in;

in vec3 tcPosition[];
in vec3 tcNormal[];

////////////////////////////////////////////////////////////////////////////////
// UNIFORM
////////////////////////////////////////////////////////////////////////////////

// Transform matrices
uniform mat4 uModelViewMatrix;
uniform mat4 uProjectionMatrix;
//uniform mat4 uModelViewProjectionMatrix;

////////////////////////////////////////////////////////////////////////////////
// OUTPUT
////////////////////////////////////////////////////////////////////////////////

out vec3 tePosition;
out vec3 teNormal;

////////////////////////////////////////////////////////////////////////////////
// PROGRAM
////////////////////////////////////////////////////////////////////////////////
void main()
{
	vec3 p0 = gl_in[ 0 ].gl_Position.xyz;
	vec3 p1 = gl_in[ 1 ].gl_Position.xyz;
	vec3 p2 = gl_in[ 2 ].gl_Position.xyz;
	
	float u = gl_TessCoord.x;
	float v = gl_TessCoord.y;
	float w = gl_TessCoord.z;

	tePosition = vec3( u * tcPosition[ 0 ] + v * tcPosition[ 1 ] + w * tcPosition[ 2 ] );
	teNormal = vec3( u * tcNormal[ 0 ] + v * tcNormal[ 1 ] + w * tcNormal[ 2 ] );

	// Send vertex to Clip space
	gl_Position = uProjectionMatrix * uModelViewMatrix * vec4( u * p0 + v * p1 + w * p2, 1.0 );
	//gl_Position = uProjectionMatrix * vec4( tePosition, 1.0 );
}
